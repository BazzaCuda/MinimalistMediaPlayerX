{   bazLib / bazAction
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}
unit bazAction;

interface

{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }
{ Add project-specific datatypes to IAction and TAction descendants in a separate unit }

type
  TVoid = record end;

  TOFuncNoParam             <TResult> = function():                                                                     TResult of object; // method of class instance
  TSFuncNoParam             <TResult> = function():                                                                     TResult;           // static method - no class instance
  TAFuncNoParam             <TResult> = reference to function():                                                        TResult;           // anonymous method

  TOFuncString              <TResult> = function(const aString: string):                                                TResult of object; // method of class instance
  TSFuncString              <TResult> = function(const aString: string):                                                TResult;           // static method - no class instance
  TAFuncString              <TResult> = reference to function(const aString: string):                                   TResult;           // anonymous method

  TOFuncInteger             <TResult> = function(const aInteger: integer):                                              TResult of object; // method of class instance
  TSFuncInteger             <TResult> = function(const aInteger: integer):                                              TResult;           // static method - no class instance
  TAFuncInteger             <TResult> = reference to function(const aInteger: integer):                                 TResult;           // anonymous method

  TOFuncStringInteger       <TResult> = function(const aString: string; const aInteger: integer):                       TResult of object; // method of class instance
  TSFuncStringInteger       <TResult> = function(const aString: string; const aInteger: integer):                       TResult;           // static method - no class instance
  TAFuncStringInteger       <TResult> = reference to function(const aString: string; const aInteger: integer):          TResult;           // anonymous method

  TOFuncBoolean             <TResult> = function(const aBoolean: boolean):                                              TResult of object; // method of class instance
  TSFuncBoolean             <TResult> = function(const aBoolean: boolean):                                              TResult;           // static method - no class instance
  TAFuncBoolean             <TResult> = reference to function(const aBoolean: boolean):                                 TResult;           // anonymous method

  TOFuncWord                <TResult> = function(const aWORD: WORD):                                                    TResult of object; // method of class instance
  TSFuncWord                <TResult> = function(const aWORD: WORD):                                                    TResult;           // static method - no class instance
  TAFuncWord                <TResult> = reference to function(const aWORD: WORD):                                       TResult;           // anonymous method

  TOFuncCardinal            <TResult> = function(const aCardinal: cardinal):                                            TResult of object; // method of class instance
  TSFuncCardinal            <TResult> = function(const aCardinal: cardinal):                                            TResult;           // static method - no class instance
  TAFuncCardinal            <TResult> = reference to function(const aCardinal: cardinal):                               TResult;           // anonymous method

  TOFuncStringString        <TResult> = function(const aString1: string; const aString2: string):                       TResult of object; // method of class instance
  TSFuncStringString        <TResult> = function(const aString1: string; const aString2: string):                       TResult;           // static method - no class instance
  TAFuncStringString        <TResult> = reference to function(const aString1: string; const aString2: string):          TResult;           // anonymous method

  TOFuncStringBoolean       <TResult> = function(const aString: string; const aBoolean: boolean):                       TResult of object; // method of class instance
  TSFuncStringBoolean       <TResult> = function(const aString: string; const aBoolean: boolean):                       TResult;           // static method - no class instance
  TAFuncStringBoolean       <TResult> = reference to function(const aString: string; const aBoolean: boolean):          TResult;           // anonymous method

  IAction<TResult> = interface
    function default(const aValue: TResult): IAction<TResult>; // the fallback value

    function perform():                                                                    TResult; overload;
    function perform(const aString: string):                                               TResult; overload;
    function perform(const aInteger: integer):                                             TResult; overload;
    function perform(const aString: string; const aInteger: integer):                      TResult; overload;
    function perform(const aBoolean: boolean):                                             TResult; overload;
    function perform(const aWORD: WORD):                                                   TResult; overload;
    function perform(const aCardinal: cardinal):                                           TResult; overload;
    function perform(const aString1: string; const aString2: string):                      TResult; overload;
    function perform(const aString: string; const aBoolean: boolean):                      TResult; overload;

    function getAssigned: boolean;
    property assigned:    boolean read getAssigned;
  end;

  TAction<TResult> = class(TInterfacedObject, IAction<TResult>)
  strict private
    FFuncAssigned: boolean;
    FDefault:      TResult; // initialised in constructor, used in perform

    FOFuncNoParam:                      TOFuncNoParam                        <TResult>;
    FSFuncNoParam:                      TAFuncNoParam                        <TResult>;
    FAFuncNoParam:                      TAFuncNoParam                        <TResult>;

    FOFuncString:                       TOFuncString                         <TResult>;
    FSFuncString:                       TAFuncString                         <TResult>;
    FAFuncString:                       TAFuncString                         <TResult>;

    FOFuncInteger:                      TOFuncInteger                        <TResult>;
    FSFuncInteger:                      TAFuncInteger                        <TResult>;
    FAFuncInteger:                      TAFuncInteger                        <TResult>;

    FOFuncStringInteger:                TOFuncStringInteger                  <TResult>;
    FSFuncStringInteger:                TAFuncStringInteger                  <TResult>;
    FAFuncStringInteger:                TAFuncStringInteger                  <TResult>;

    FOFuncBoolean:                      TOFuncBoolean                        <TResult>;
    FSFuncBoolean:                      TAFuncBoolean                        <TResult>;
    FAFuncBoolean:                      TAFuncBoolean                        <TResult>;

    FOFuncWord:                         TOFuncWord                           <TResult>;
    FSFuncWord:                         TAFuncWord                           <TResult>;
    FAFuncWord:                         TAFuncWord                           <TResult>;

    FOFuncCardinal:                     TOFuncCardinal                       <TResult>;
    FSFuncCardinal:                     TAFuncCardinal                       <TResult>;
    FAFuncCardinal:                     TAFuncCardinal                       <TResult>;

    FOFuncStringString:                 TOFuncStringString                   <TResult>;
    FSFuncStringString:                 TAFuncStringString                   <TResult>;
    FAFuncStringString:                 TAFuncStringString                   <TResult>;

    FOFuncStringBoolean:                TOFuncStringBoolean                  <TResult>;
    FSFuncStringBoolean:                TAFuncStringBoolean                  <TResult>;
    FAFuncStringBoolean:                TAFuncStringBoolean                  <TResult>;

    constructor Create;                           overload;
    constructor Create(const aFuncNIL: pointer);  overload;

    constructor Create(const aFuncNoParam:           TOFuncNoParam            <TResult>);     overload;
    constructor Create(const aFuncNoParam:           TSFuncNoParam            <TResult>);     overload;
    constructor Create(const aFuncNoParam:           TAFuncNoParam            <TResult>);     overload;

    constructor Create(const aFuncString:            TOFuncString             <TResult>);     overload;
    constructor Create(const aFuncString:            TSFuncString             <TResult>);     overload;
    constructor Create(const aFuncString:            TAFuncString             <TResult>);     overload;

    constructor Create(const aFuncInteger:           TOFuncInteger            <TResult>);     overload;
    constructor Create(const aFuncInteger:           TSFuncInteger            <TResult>);     overload;
    constructor Create(const aFuncInteger:           TAFuncInteger            <TResult>);     overload;

    constructor Create(const aFuncStringInteger:     TOFuncStringInteger      <TResult>);     overload;
    constructor Create(const aFuncStringInteger:     TSFuncStringInteger      <TResult>);     overload;
    constructor Create(const aFuncStringInteger:     TAFuncStringInteger      <TResult>);     overload;

    constructor Create(const aFuncBoolean:           TOFuncBoolean            <TResult>);     overload;
    constructor Create(const aFuncBoolean:           TSFuncBoolean            <TResult>);     overload;
    constructor Create(const aFuncBoolean:           TAFuncBoolean            <TResult>);     overload;

    constructor Create(const aFuncWord:              TOFuncWord               <TResult>);     overload;
    constructor Create(const aFuncWord:              TSFuncWord               <TResult>);     overload;
    constructor Create(const aFuncWord:              TAFuncWord               <TResult>);     overload;

    constructor Create(const aFuncCardinal:          TOFuncCardinal           <TResult>);     overload;
    constructor Create(const aFuncCardinal:          TSFuncCardinal           <TResult>);     overload;
    constructor Create(const aFuncCardinal:          TAFuncCardinal           <TResult>);     overload;

    constructor Create(const aFuncStringString:      TOFuncStringString       <TResult>);     overload;
    constructor Create(const aFuncStringString:      TSFuncStringString       <TResult>);     overload;
    constructor Create(const aFuncStringString:      TAFuncStringString       <TResult>);     overload;

    constructor Create(const aFuncStringBoolean:     TOFuncStringBoolean      <TResult>);     overload;
    constructor Create(const aFuncStringBoolean:     TSFuncStringBoolean      <TResult>);     overload;
    constructor Create(const aFuncStringBoolean:     TAFuncStringBoolean      <TResult>);     overload;

  public
    function getAssigned: boolean;
    function default(const aValue: TResult): IAction<TResult>;

    class function pick(const aBoolean: boolean; const aTrueFuncNoParam:            TOFuncNoParam            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncNoParam:            TSFuncNoParam            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncNoParam:            TAFuncNoParam            <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncString:             TOFuncString             <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncString:             TSFuncString             <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncString:             TAFuncString             <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncInteger:            TOFuncInteger            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncInteger:            TSFuncInteger            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncInteger:            TAFuncInteger            <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncStringInteger:      TOFuncStringInteger      <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncStringInteger:      TSFuncStringInteger      <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncStringInteger:      TAFuncStringInteger      <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncBoolean:            TOFuncBoolean            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncBoolean:            TSFuncBoolean            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncBoolean:            TAFuncBoolean            <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncWord:               TOFuncWord               <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncWord:               TSFuncWord               <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncWord:               TAFuncWord               <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncCardinal:           TOFuncCardinal           <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncCardinal:           TSFuncCardinal           <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncCardinal:           TAFuncCardinal           <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncStringString:       TOFuncStringString       <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncStringString:       TSFuncStringString       <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncStringString:       TAFuncStringString       <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncStringBoolean:      TOFuncStringBoolean      <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncStringBoolean:      TSFuncStringBoolean      <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncStringBoolean:      TAFuncStringBoolean      <TResult>):           IAction<TResult>; overload;

    function perform():                                                          TResult; overload;
    function perform(const aString: string):                                     TResult; overload;
    function perform(const aInteger: integer):                                   TResult; overload;
    function perform(const aString: string; const aInteger: integer):            TResult; overload;
    function perform(const aBoolean: boolean):                                   TResult; overload;
    function perform(const aWORD: WORD):                                         TResult; overload;
    function perform(const aCardinal: cardinal):                                 TResult; overload;
    function perform(const aString1: string; const aString2: string):            TResult; overload;
    function perform(const aString: string; const aBoolean: boolean):            TResult; overload;
  end;

implementation

uses
  bazRTL;

{ TAction<TResult> }

constructor TAction<TResult>.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction<TResult>.Create(const aFuncNIL: pointer);
begin
  case aFuncNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Functionless constructor must be called with NIL'); end;
end;

constructor TAction<TResult>.Create(const aFuncNoParam: TOFuncNoParam<TResult>);
begin
  FOFuncNoParam        := aFuncNoParam;
  FFuncAssigned        := assigned(aFuncNoParam);
end;

constructor TAction<TResult>.Create(const aFuncNoParam: TSFuncNoParam<TResult>);
begin
  FSFuncNoParam        := aFuncNoParam;
  FFuncAssigned        := assigned(aFuncNoParam);
end;

constructor TAction<TResult>.Create(const aFuncNoParam: TAFuncNoParam<TResult>);
begin
  FAFuncNoParam        := aFuncNoParam;
  FFuncAssigned        := assigned(aFuncNoParam);
end;

constructor TAction<TResult>.Create(const aFuncString: TOFuncString<TResult>);
begin
  FOFuncString         := aFuncString;
  FFuncAssigned        := assigned(aFuncString);
end;

constructor TAction<TResult>.Create(const aFuncString: TSFuncString<TResult>);
begin
  FSFuncString         := aFuncString;
  FFuncAssigned        := assigned(aFuncString);
end;

constructor TAction<TResult>.Create(const aFuncString: TAFuncString<TResult>);
begin
  FAFuncString         := aFuncString;
  FFuncAssigned        := assigned(aFuncString);
end;

constructor TAction<TResult>.Create(const aFuncInteger: TOFuncInteger<TResult>);
begin
  FOFuncInteger        := aFuncInteger;
  FFuncAssigned        := assigned(aFuncInteger);
end;

constructor TAction<TResult>.Create(const aFuncInteger: TSFuncInteger<TResult>);
begin
  FSFuncInteger        := aFuncInteger;
  FFuncAssigned        := assigned(aFuncInteger);
end;

constructor TAction<TResult>.Create(const aFuncInteger: TAFuncInteger<TResult>);
begin
  FAFuncInteger        := aFuncInteger;
  FFuncAssigned        := assigned(aFuncInteger);
end;

constructor TAction<TResult>.Create(const aFuncStringInteger: TOFuncStringInteger<TResult>);
begin
  FOFuncStringInteger  := aFuncStringInteger;
  FFuncAssigned        := assigned(aFuncStringInteger);
end;

constructor TAction<TResult>.Create(const aFuncStringInteger: TSFuncStringInteger<TResult>);
begin
  FSFuncStringInteger  := aFuncStringInteger;
  FFuncAssigned        := assigned(aFuncStringInteger);
end;

constructor TAction<TResult>.Create(const aFuncStringInteger: TAFuncStringInteger<TResult>);
begin
  FAFuncStringInteger  := aFuncStringInteger;
  FFuncAssigned        := assigned(aFuncStringInteger);
end;

constructor TAction<TResult>.Create(const aFuncBoolean: TOFuncBoolean<TResult>);
begin
  FOFuncBoolean        := aFuncBoolean;
  FFuncAssigned        := assigned(aFuncBoolean);
end;

constructor TAction<TResult>.Create(const aFuncBoolean: TSFuncBoolean<TResult>);
begin
  FSFuncBoolean        := aFuncBoolean;
  FFuncAssigned        := assigned(aFuncBoolean);
end;

constructor TAction<TResult>.Create(const aFuncBoolean: TAFuncBoolean<TResult>);
begin
  FAFuncBoolean        := aFuncBoolean;
  FFuncAssigned        := assigned(aFuncBoolean);
end;

constructor TAction<TResult>.Create(const aFuncWord: TOFuncWord<TResult>);
begin
  FOFuncWord           := aFuncWord;
  FFuncAssigned        := assigned(aFuncWord);
end;

constructor TAction<TResult>.Create(const aFuncWord: TSFuncWord<TResult>);
begin
  FSFuncWord           := aFuncWord;
  FFuncAssigned        := assigned(aFuncWord);
end;

constructor TAction<TResult>.Create(const aFuncWord: TAFuncWord<TResult>);
begin
  FAFuncWord           := aFuncWord;
  FFuncAssigned        := assigned(aFuncWord);
end;

constructor TAction<TResult>.Create(const aFuncCardinal: TOFuncCardinal<TResult>);
begin
  FOFuncCardinal       := aFuncCardinal;
  FFuncAssigned        := assigned(aFuncCardinal);
end;

constructor TAction<TResult>.Create(const aFuncCardinal: TSFuncCardinal<TResult>);
begin
  FSFuncCardinal       := aFuncCardinal;
  FFuncAssigned        := assigned(aFuncCardinal);
end;

constructor TAction<TResult>.Create(const aFuncCardinal: TAFuncCardinal<TResult>);
begin
  FAFuncCardinal       := aFuncCardinal;
  FFuncAssigned        := assigned(aFuncCardinal);
end;

constructor TAction<TResult>.Create(const aFuncStringString: TOFuncStringString<TResult>);
begin
  FOFuncStringString   := aFuncStringString;
  FFuncAssigned        := assigned(aFuncStringString);
end;

constructor TAction<TResult>.Create(const aFuncStringString: TSFuncStringString<TResult>);
begin
  FSFuncStringString   := aFuncStringString;
  FFuncAssigned        := assigned(aFuncStringString);
end;

constructor TAction<TResult>.Create(const aFuncStringString: TAFuncStringString<TResult>);
begin
  FAFuncStringString   := aFuncStringString;
  FFuncAssigned        := assigned(aFuncStringString);
end;

constructor TAction<TResult>.Create(const aFuncStringBoolean: TOFuncStringBoolean<TResult>);
begin
  FOFuncStringBoolean  := aFuncStringBoolean;
  FFuncAssigned        := assigned(aFuncStringBoolean);
end;

constructor TAction<TResult>.Create(const aFuncStringBoolean: TSFuncStringBoolean<TResult>);
begin
  FSFuncStringBoolean  := aFuncStringBoolean;
  FFuncAssigned        := assigned(aFuncStringBoolean);
end;

constructor TAction<TResult>.Create(const aFuncStringBoolean: TAFuncStringBoolean<TResult>);
begin
  FAFuncStringBoolean  := aFuncStringBoolean;
  FFuncAssigned        := assigned(aFuncStringBoolean);
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncNoParam: TOFuncNoParam<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncNoParam);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncNoParam: TSFuncNoParam<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncNoParam);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncNoParam: TAFuncNoParam<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncNoParam);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncString: TOFuncString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncString);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncString: TSFuncString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncString);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncString: TAFuncString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncString);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncInteger: TOFuncInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncInteger: TSFuncInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncInteger: TAFuncInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringInteger: TOFuncStringInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringInteger: TSFuncStringInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringInteger: TAFuncStringInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncBoolean: TOFuncBoolean<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncBoolean);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncBoolean: TSFuncBoolean<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncBoolean);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncBoolean: TAFuncBoolean<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncBoolean);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncWord: TOFuncWord<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncWord);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncWord: TSFuncWord<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncWord);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncWord: TAFuncWord<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncWord);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncCardinal: TOFuncCardinal<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncCardinal);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncCardinal: TSFuncCardinal<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncCardinal);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncCardinal: TAFuncCardinal<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncCardinal);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringString: TOFuncStringString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringString);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringString: TSFuncStringString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringString);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringString: TAFuncStringString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringString);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringBoolean: TOFuncStringBoolean<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringBoolean);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringBoolean: TSFuncStringBoolean<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringBoolean);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringBoolean: TAFuncStringBoolean<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringBoolean);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

function TAction<TResult>.getAssigned: boolean;
begin
  result := FFuncAssigned;
end;

function TAction<TResult>.default(const aValue: TResult): IAction<TResult>;
begin
  FDefault := aValue;
  result   := SELF;
end;

function TAction<TResult>.perform(): TResult;
begin
  result := FDefault;
  case assigned(FOFuncNoParam) of TRUE: EXIT(FOFuncNoParam()); end;
  case assigned(FSFuncNoParam) of TRUE: EXIT(FSFuncNoParam()); end;
  case assigned(FAFuncNoParam) of TRUE: EXIT(FAFuncNoParam()); end;
end;

function TAction<TResult>.perform(const aString: string): TResult;
begin
  result := FDefault;
  case assigned(FOFuncString) of TRUE: EXIT(FOFuncString(aString)); end;
  case assigned(FSFuncString) of TRUE: EXIT(FSFuncString(aString)); end;
  case assigned(FAFuncString) of TRUE: EXIT(FAFuncString(aString)); end;
end;

function TAction<TResult>.perform(const aInteger: integer): TResult;
begin
  result := FDefault;
  case assigned(FOFuncInteger) of TRUE: EXIT(FOFuncInteger(aInteger)); end;
  case assigned(FSFuncInteger) of TRUE: EXIT(FSFuncInteger(aInteger)); end;
  case assigned(FAFuncInteger) of TRUE: EXIT(FAFuncInteger(aInteger)); end;
end;

function TAction<TResult>.perform(const aString: string; const aInteger: integer): TResult;
begin
  result := FDefault;
  case assigned(FOFuncStringInteger) of TRUE: EXIT(FOFuncStringInteger(aString, aInteger)); end;
  case assigned(FSFuncStringInteger) of TRUE: EXIT(FSFuncStringInteger(aString, aInteger)); end;
  case assigned(FAFuncStringInteger) of TRUE: EXIT(FAFuncStringInteger(aString, aInteger)); end;
end;

function TAction<TResult>.perform(const aBoolean: boolean): TResult;
begin
  result := FDefault;
  case assigned(FOFuncBoolean) of TRUE: EXIT(FOFuncBoolean(aBoolean)); end;
  case assigned(FSFuncBoolean) of TRUE: EXIT(FSFuncBoolean(aBoolean)); end;
  case assigned(FAFuncBoolean) of TRUE: EXIT(FAFuncBoolean(aBoolean)); end;
end;

function TAction<TResult>.perform(const aWORD: WORD): TResult;
begin
  result := FDefault;
  case assigned(FOFuncWord) of TRUE: EXIT(FOFuncWord(aWORD)); end;
  case assigned(FSFuncWord) of TRUE: EXIT(FSFuncWord(aWORD)); end;
  case assigned(FAFuncWord) of TRUE: EXIT(FAFuncWord(aWORD)); end;
end;

function TAction<TResult>.perform(const aCardinal: cardinal): TResult;
begin
  result := FDefault;
  case assigned(FOFuncCardinal) of TRUE: EXIT(FOFuncCardinal(aCardinal)); end;
  case assigned(FSFuncCardinal) of TRUE: EXIT(FSFuncCardinal(aCardinal)); end;
  case assigned(FAFuncCardinal) of TRUE: EXIT(FAFuncCardinal(aCardinal)); end;
end;

function TAction<TResult>.perform(const aString1: string; const aString2: string): TResult;
begin
  result := FDefault;
  case assigned(FOFuncStringString) of TRUE: EXIT(FOFuncStringString(aString1, aString2)); end;
  case assigned(FSFuncStringString) of TRUE: EXIT(FSFuncStringString(aString1, aString2)); end;
  case assigned(FAFuncStringString) of TRUE: EXIT(FAFuncStringString(aString1, aString2)); end;
end;

function TAction<TResult>.perform(const aString: string; const aBoolean: boolean): TResult;
begin
  result := FDefault;
  case assigned(FOFuncStringBoolean) of TRUE: EXIT(FOFuncStringBoolean(aString, aBoolean)); end;
  case assigned(FSFuncStringBoolean) of TRUE: EXIT(FSFuncStringBoolean(aString, aBoolean)); end;
  case assigned(FAFuncStringBoolean) of TRUE: EXIT(FAFuncStringBoolean(aString, aBoolean)); end;
end;

end.
