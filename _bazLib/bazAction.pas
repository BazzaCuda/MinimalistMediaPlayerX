{   bazLib / bazAction
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/bazLib

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}
unit bazAction;

interface

{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }
{ Add project-specific datatypes to TAction descendants in a separate unit }

uses
  _debugWindow;
  
type
  TVoid = record end;

  TFunc<T> = reference to function: T;
  TAFuncNoParam             <TResult> = reference to function():                                                        TResult;
  TAFuncString              <TResult> = reference to function(const aString: string):                                   TResult;
  TAFuncInteger             <TResult> = reference to function(const aInteger: integer):                                 TResult;
  TAFuncStringInteger       <TResult> = reference to function(const aString: string; const aInteger: integer):          TResult;
  TAFuncBoolean             <TResult> = reference to function(const aBoolean: boolean):                                 TResult;
  TAFuncWord                <TResult> = reference to function(const aWORD: WORD):                                       TResult;
  TAFuncCardinal            <TResult> = reference to function(const aCardinal: cardinal):                               TResult;
  TAFuncStringString        <TResult> = reference to function(const aString1: string; const aString2: string):          TResult;
  TAFuncStringBoolean       <TResult> = reference to function(const aString: string; const aBoolean: boolean):          TResult;

  TAProcNoParam              = reference to procedure()                                                        ;
  TAProcString               = reference to procedure(const aString: string)                                   ;
  TAProcInteger              = reference to procedure(const aInteger: integer)                                 ;
  TAProcStringInteger        = reference to procedure(const aString: string; const aInteger: integer)          ;
  TAProcBoolean              = reference to procedure(const aBoolean: boolean)                                 ;
  TAProcWord                 = reference to procedure(const aWORD: WORD)                                       ;
  TAProcCardinal             = reference to procedure(const aCardinal: cardinal)                               ;
  TAProcStringString         = reference to procedure(const aString1: string; const aString2: string)          ;
  TAProcStringBoolean        = reference to procedure(const aString: string; const aBoolean: boolean)          ;

  TAction<TResult> = class
  strict private
    FMethodAssigned: boolean;
    FSuccess:        boolean;
    FDefault:        TResult; // initialised by constructor, set by optional .default(), used in .perform()

    FAFuncNoParam:                      TAFuncNoParam                        <TResult>;
    FAFuncString:                       TAFuncString                         <TResult>;
    FAFuncInteger:                      TAFuncInteger                        <TResult>;
    FAFuncStringInteger:                TAFuncStringInteger                  <TResult>;
    FAFuncBoolean:                      TAFuncBoolean                        <TResult>;
    FAFuncWord:                         TAFuncWord                           <TResult>;
    FAFuncCardinal:                     TAFuncCardinal                       <TResult>;
    FAFuncStringString:                 TAFuncStringString                   <TResult>;
    FAFuncStringBoolean:                TAFuncStringBoolean                  <TResult>;

    constructor Create;                           overload;
    constructor Create(const aFuncNIL: pointer);  overload;
    constructor Create(const aFuncNoParam:           TAFuncNoParam            <TResult>);     overload;
    constructor Create(const aFuncString:            TAFuncString             <TResult>);     overload;
    constructor Create(const aFuncInteger:           TAFuncInteger            <TResult>);     overload;
    constructor Create(const aFuncStringInteger:     TAFuncStringInteger      <TResult>);     overload;
    constructor Create(const aFuncBoolean:           TAFuncBoolean            <TResult>);     overload;
    constructor Create(const aFuncWord:              TAFuncWord               <TResult>);     overload;
    constructor Create(const aFuncCardinal:          TAFuncCardinal           <TResult>);     overload;
    constructor Create(const aFuncStringString:      TAFuncStringString       <TResult>);     overload;
    constructor Create(const aFuncStringBoolean:     TAFuncStringBoolean      <TResult>);     overload;
  protected
  public
    function  getMethodAssigned: boolean;
    procedure setMethodAssigned(const aValue: boolean);
    function  getSuccess:        boolean;
    procedure setSuccess(const aValue: boolean);
    function  default(const aValue: TResult): TAction<TResult>;
    function  getDefault: TResult;
    function  ensure(const aGuardClause: boolean): TAction<TResult>;
    function  assign<T>(var aTarget: T; const aValue: T): TAction<TResult>; overload;
    function  assign<T>(const aGuardClause: boolean; var aTarget: T; const aValue: T): TAction<TResult>; overload;
    function  assignFrom<T>(var aTarget: T; const aValue: TFunc<T>): TAction<TResult>; overload;
    function  assignFrom<T>(const aGuardClause: boolean; var aTarget: T; const aValue: TFunc<T>): TAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncNoParam<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncNoParam<TResult>; const aFalseFunc: TAFuncNoParam<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncString<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncString<TResult>; const aFalseFunc: TAFuncString<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncInteger<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncInteger<TResult>; const aFalseFunc: TAFuncInteger<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringInteger<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringInteger<TResult>; const aFalseFunc: TAFuncStringInteger<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncBoolean<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncBoolean<TResult>; const aFalseFunc: TAFuncBoolean<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncWord<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncWord<TResult>; const aFalseFunc: TAFuncWord<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncCardinal<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncCardinal<TResult>; const aFalseFunc: TAFuncCardinal<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringString<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringString<TResult>; const aFalseFunc: TAFuncStringString<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringBoolean<TResult>): TAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringBoolean<TResult>; const aFalseFunc: TAFuncStringBoolean<TResult>): TAction<TResult>; overload;

    function  perform(): TResult; overload;
    function  perform(const aString: string): TResult; overload;
    function  perform(const aInteger: integer): TResult; overload;
    function  perform(const aString: string; const aInteger: integer): TResult; overload;
    function  perform(const aBoolean: boolean): TResult; overload;
    function  perform(const aWORD: WORD): TResult; overload;
    function  perform(const aCardinal: cardinal): TResult; overload;
    function  perform(const aString1: string; const aString2: string): TResult; overload;
    function  perform(const aString: string; const aBoolean: boolean): TResult; overload;

    class function startWith(const aBoolean: boolean): TAction<TResult>;
    class function startWithNot(const aBoolean: boolean): TAction<TResult>;

    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncNoParam<boolean>): TAction<TResult>; overload;
    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncString<boolean>; const aString: string): TAction<TResult>; overload;
    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncInteger<boolean>; const aInteger: integer): TAction<TResult>; overload;
    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncStringInteger<boolean>; const aString: string; const aInteger: integer): TAction<TResult>; overload;
    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncBoolean<boolean>; const aBoolean: boolean): TAction<TResult>; overload;
    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncWord<boolean>; const aWORD: WORD): TAction<TResult>; overload;
    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncCardinal<boolean>; const aCardinal: cardinal): TAction<TResult>; overload;
    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncStringString<boolean>; const aString1: string; const aString2: string): TAction<TResult>; overload;
    function  andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncStringBoolean<boolean>; const aString: string; const aBoolean: boolean): TAction<TResult>; overload;

    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncNoParam<boolean>): TAction<TResult>; overload;
    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncString<boolean>; const aString: string): TAction<TResult>; overload;
    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncInteger<boolean>; const aInteger: integer): TAction<TResult>; overload;
    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncStringInteger<boolean>; const aString: string; const aInteger: integer): TAction<TResult>; overload;
    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncBoolean<boolean>; const aBoolean: boolean): TAction<TResult>; overload;
    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncWord<boolean>; const aWORD: WORD): TAction<TResult>; overload;
    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncCardinal<boolean>; const aCardinal: cardinal): TAction<TResult>; overload;
    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncStringString<boolean>; const aString1: string; const aString2: string): TAction<TResult>; overload;
    function  aside(const aGuardClause: boolean; const aTrueFunc: TAFuncStringBoolean<boolean>; const aString: string; const aBoolean: boolean): TAction<TResult>; overload;

    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncNoParam<T>): TAction<TResult>; overload;
    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncString<T>; const aString: string): TAction<TResult>; overload;
    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncInteger<T>; const aInteger: integer): TAction<TResult>; overload;
    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncStringInteger<T>; const aString: string; const aInteger: integer): TAction<TResult>; overload;
    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncBoolean<T>; const aBoolean: boolean): TAction<TResult>; overload;
    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncWord<T>; const aWORD: WORD): TAction<TResult>; overload;
    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncCardinal<T>; const aCardinal: cardinal): TAction<TResult>; overload;
    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncStringString<T>; const aString1: string; const aString2: string): TAction<TResult>; overload;
    function  aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncStringBoolean<T>; const aString: string; const aBoolean: boolean): TAction<TResult>; overload;

    function  thenStop: boolean;

    property  success:        boolean read getSuccess         write setSuccess;
    property  methodAssigned: boolean read getMethodAssigned  write setMethodAssigned;
  end;

  TAction = class
  strict private
    FMethodAssigned: boolean;

    FAProcNoParam:                      TAProcNoParam                        ;
    FAProcString:                       TAProcString                         ;
    FAProcInteger:                      TAProcInteger                        ;
    FAProcStringInteger:                TAProcStringInteger                  ;
    FAProcBoolean:                      TAProcBoolean                        ;
    FAProcWord:                         TAProcWord                           ;
    FAProcCardinal:                     TAProcCardinal                       ;
    FAProcStringString:                 TAProcStringString                   ;
    FAProcStringBoolean:                TAProcStringBoolean                  ;

    constructor Create;                           overload;
    constructor Create(const aProcNIL: pointer);  overload;
    constructor Create(const aProcNoParam:           TAProcNoParam             );     overload;
    constructor Create(const aProcString:            TAProcString              );     overload;
    constructor Create(const aProcInteger:           TAProcInteger             );     overload;
    constructor Create(const aProcStringInteger:     TAProcStringInteger       );     overload;
    constructor Create(const aProcBoolean:           TAProcBoolean             );     overload;
    constructor Create(const aProcWord:              TAProcWord                );     overload;
    constructor Create(const aProcCardinal:          TAProcCardinal            );     overload;
    constructor Create(const aProcStringString:      TAProcStringString        );     overload;
    constructor Create(const aProcStringBoolean:     TAProcStringBoolean       );     overload;
  protected
  public
    function  getMethodAssigned: boolean;
    procedure setMethodAssigned(const aValue: boolean);

    class function pick(const aBoolean: boolean; const aTrueProc: TAProcNoParam): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcNoParam; const aFalseProc: TAProcNoParam): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcString): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcString; const aFalseProc: TAProcString): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcInteger): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcInteger; const aFalseProc: TAProcInteger): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcStringInteger): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcStringInteger; const aFalseProc: TAProcStringInteger): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcBoolean): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcBoolean; const aFalseProc: TAProcBoolean): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcWord): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcWord; const aFalseProc: TAProcWord): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcCardinal): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcCardinal; const aFalseProc: TAProcCardinal): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcStringString): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcStringString; const aFalseProc: TAProcStringString): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcStringBoolean): TAction; overload;
    class function pick(const aBoolean: boolean; const aTrueProc: TAProcStringBoolean; const aFalseProc: TAProcStringBoolean): TAction; overload;

    procedure  perform(); overload;
    procedure  perform(const aString: string); overload;
    procedure  perform(const aInteger: integer); overload;
    procedure  perform(const aString: string; const aInteger: integer); overload;
    procedure  perform(const aBoolean: boolean); overload;
    procedure  perform(const aWORD: WORD); overload;
    procedure  perform(const aCardinal: cardinal); overload;
    procedure  perform(const aString1: string; const aString2: string); overload;
    procedure  perform(const aString: string; const aBoolean: boolean); overload;




    property  methodAssigned: boolean read getMethodAssigned  write setMethodAssigned;
  end;

implementation

uses
  bazRTL;

{ TAction<TResult> }

constructor TAction<TResult>.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction<TResult>.Create(const aFuncNIL: pointer);
begin
  case aFuncNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Methodless constructor must be called with NIL'); end;
end;
constructor TAction<TResult>.Create(const aFuncNoParam: TAFuncNoParam<TResult>);
begin
  FAFuncNoParam        := aFuncNoParam;
  methodAssigned       := assigned(aFuncNoParam);
end;

constructor TAction<TResult>.Create(const aFuncString: TAFuncString<TResult>);
begin
  FAFuncString         := aFuncString;
  methodAssigned       := assigned(aFuncString);
end;

constructor TAction<TResult>.Create(const aFuncInteger: TAFuncInteger<TResult>);
begin
  FAFuncInteger        := aFuncInteger;
  methodAssigned       := assigned(aFuncInteger);
end;

constructor TAction<TResult>.Create(const aFuncStringInteger: TAFuncStringInteger<TResult>);
begin
  FAFuncStringInteger  := aFuncStringInteger;
  methodAssigned       := assigned(aFuncStringInteger);
end;

constructor TAction<TResult>.Create(const aFuncBoolean: TAFuncBoolean<TResult>);
begin
  FAFuncBoolean        := aFuncBoolean;
  methodAssigned       := assigned(aFuncBoolean);
end;

constructor TAction<TResult>.Create(const aFuncWord: TAFuncWord<TResult>);
begin
  FAFuncWord           := aFuncWord;
  methodAssigned       := assigned(aFuncWord);
end;

constructor TAction<TResult>.Create(const aFuncCardinal: TAFuncCardinal<TResult>);
begin
  FAFuncCardinal       := aFuncCardinal;
  methodAssigned       := assigned(aFuncCardinal);
end;

constructor TAction<TResult>.Create(const aFuncStringString: TAFuncStringString<TResult>);
begin
  FAFuncStringString   := aFuncStringString;
  methodAssigned       := assigned(aFuncStringString);
end;

constructor TAction<TResult>.Create(const aFuncStringBoolean: TAFuncStringBoolean<TResult>);
begin
  FAFuncStringBoolean  := aFuncStringBoolean;
  methodAssigned       := assigned(aFuncStringBoolean);
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncNoParam<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncString<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncInteger<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringInteger<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncBoolean<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncWord<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncCardinal<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringString<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringBoolean<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncNoParam<TResult>; const aFalseFunc: TAFuncNoParam<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncString<TResult>; const aFalseFunc: TAFuncString<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncInteger<TResult>; const aFalseFunc: TAFuncInteger<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringInteger<TResult>; const aFalseFunc: TAFuncStringInteger<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncBoolean<TResult>; const aFalseFunc: TAFuncBoolean<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncWord<TResult>; const aFalseFunc: TAFuncWord<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncCardinal<TResult>; const aFalseFunc: TAFuncCardinal<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringString<TResult>; const aFalseFunc: TAFuncStringString<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFunc: TAFuncStringBoolean<TResult>; const aFalseFunc: TAFuncStringBoolean<TResult>): TAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFunc);
    FALSE:  result := TAction<TResult>.Create(aFalseFunc);
  end;
end;


function TAction<TResult>.getMethodAssigned: boolean;
begin
  result := FMethodAssigned;
end;

procedure TAction<TResult>.setMethodAssigned(const aValue: boolean);
begin
  FMethodAssigned := aValue;
end;

function TAction<TResult>.default(const aValue: TResult): TAction<TResult>;
begin
  FDefault := aValue;
  result   := SELF;
end;

function TAction<TResult>.getDefault: TResult;
begin
  result := FDefault
end;

function TAction<TResult>.ensure(const aGuardClause: boolean): TAction<TResult>;
begin
  success := success and aGuardClause;
  result := SELF;
end;

function TAction<TResult>.assign<T>(var aTarget: T; const aValue: T): TAction<TResult>;
begin
  case success of TRUE: aTarget := aValue; end;
  result  := SELF;
end;

function TAction<TResult>.assign<T>(const aGuardClause: boolean; var aTarget: T; const aValue: T): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTarget := aValue; end;
  result  := SELF;
end;

function TAction<TResult>.assignFrom<T>(var aTarget: T; const aValue: TFunc<T>): TAction<TResult>;
begin
  case success of TRUE: aTarget := aValue(); end;
  result  := SELF;
end;

function TAction<TResult>.assignFrom<T>(const aGuardClause: boolean; var aTarget: T; const aValue: TFunc<T>): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTarget := aValue(); end;
  result  := SELF;
end;

function TAction<TResult>.perform(): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncNoParam) of TRUE: EXIT(FAFuncNoParam()); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.perform(const aString: string): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncString) of TRUE: EXIT(FAFuncString(aString)); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.perform(const aInteger: integer): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncInteger) of TRUE: EXIT(FAFuncInteger(aInteger)); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.perform(const aString: string; const aInteger: integer): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncStringInteger) of TRUE: EXIT(FAFuncStringInteger(aString, aInteger)); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.perform(const aBoolean: boolean): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncBoolean) of TRUE: EXIT(FAFuncBoolean(aBoolean)); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.perform(const aWORD: WORD): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncWord) of TRUE: EXIT(FAFuncWord(aWORD)); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.perform(const aCardinal: cardinal): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncCardinal) of TRUE: EXIT(FAFuncCardinal(aCardinal)); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.perform(const aString1: string; const aString2: string): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncStringString) of TRUE: EXIT(FAFuncStringString(aString1, aString2)); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.perform(const aString: string; const aBoolean: boolean): TResult;
begin
  result := getDefault;
  try
    case assigned(FAFuncStringBoolean) of TRUE: EXIT(FAFuncStringBoolean(aString, aBoolean)); end;
  finally
    SELF.free;
  end;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncNoParam<boolean>): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(); end;
  result := SELF;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncString<boolean>; const aString: string): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(aString); end;
  result := SELF;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncInteger<boolean>; const aInteger: integer): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(aInteger); end;
  result := SELF;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncStringInteger<boolean>; const aString: string; const aInteger: integer): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(aString, aInteger); end;
  result := SELF;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncBoolean<boolean>; const aBoolean: boolean): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(aBoolean); end;
  result := SELF;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncWord<boolean>; const aWORD: WORD): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(aWORD); end;
  result := SELF;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncCardinal<boolean>; const aCardinal: cardinal): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(aCardinal); end;
  result := SELF;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncStringString<boolean>; const aString1: string; const aString2: string): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(aString1, aString2); end;
  result := SELF;
end;

function TAction<TResult>.andThen(const aGuardClause: boolean; const aTrueFunc: TAFuncStringBoolean<boolean>; const aString: string; const aBoolean: boolean): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: success := aTrueFunc(aString, aBoolean); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncNoParam<boolean>): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncString<boolean>; const aString: string): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aString); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncInteger<boolean>; const aInteger: integer): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aInteger); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncStringInteger<boolean>; const aString: string; const aInteger: integer): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aString, aInteger); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncBoolean<boolean>; const aBoolean: boolean): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aBoolean); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncWord<boolean>; const aWORD: WORD): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aWORD); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncCardinal<boolean>; const aCardinal: cardinal): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aCardinal); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncStringString<boolean>; const aString1: string; const aString2: string): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aString1, aString2); end;
  result := SELF;
end;

function TAction<TResult>.aside(const aGuardClause: boolean; const aTrueFunc: TAFuncStringBoolean<boolean>; const aString: string; const aBoolean: boolean): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aString, aBoolean); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncNoParam<T>): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncString<T>; const aString: string): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aString); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncInteger<T>; const aInteger: integer): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aInteger); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncStringInteger<T>; const aString: string; const aInteger: integer): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aString, aInteger); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncBoolean<T>; const aBoolean: boolean): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aBoolean); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncWord<T>; const aWORD: WORD): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aWORD); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncCardinal<T>; const aCardinal: cardinal): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aCardinal); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncStringString<T>; const aString1: string; const aString2: string): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aString1, aString2); end;
  result := SELF;
end;

function TAction<TResult>.aside<T>(const aGuardClause: boolean; const aTrueFunc: TAFuncStringBoolean<T>; const aString: string; const aBoolean: boolean): TAction<TResult>;
begin
  case success and aGuardClause of TRUE: aTrueFunc(aString, aBoolean); end;
  result := SELF;
end;

function TAction<TResult>.getSuccess: boolean;
begin
  result := FSuccess;
end;

procedure TAction<TResult>.setSuccess(const aValue: boolean);
begin
  FSuccess := aValue;
end;

class function TAction<TResult>.startWith(const aBoolean: boolean): TAction<TResult>;
begin
  result             := TAction<TResult>.Create(NIL);
  result.success     := aBoolean;
end;

class function TAction<TResult>.startWithNot(const aBoolean: boolean): TAction<TResult>;
begin
  result             := TAction<TResult>.Create(NIL);
  result.success     := NOT aBoolean;
end;

function TAction<TResult>.thenStop: boolean;
begin
  result := FSuccess;
  SELF.free;
end;

{ TAction }

constructor TAction.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction.Create(const aProcNIL: pointer);
begin
  case aProcNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Methodless constructor must be called with NIL'); end;
end;
constructor TAction.Create(const aProcNoParam: TAProcNoParam);
begin
  FAProcNoParam        := aProcNoParam;
  methodAssigned       := assigned(aProcNoParam);
end;

constructor TAction.Create(const aProcString: TAProcString);
begin
  FAProcString         := aProcString;
  methodAssigned       := assigned(aProcString);
end;

constructor TAction.Create(const aProcInteger: TAProcInteger);
begin
  FAProcInteger        := aProcInteger;
  methodAssigned       := assigned(aProcInteger);
end;

constructor TAction.Create(const aProcStringInteger: TAProcStringInteger);
begin
  FAProcStringInteger  := aProcStringInteger;
  methodAssigned       := assigned(aProcStringInteger);
end;

constructor TAction.Create(const aProcBoolean: TAProcBoolean);
begin
  FAProcBoolean        := aProcBoolean;
  methodAssigned       := assigned(aProcBoolean);
end;

constructor TAction.Create(const aProcWord: TAProcWord);
begin
  FAProcWord           := aProcWord;
  methodAssigned       := assigned(aProcWord);
end;

constructor TAction.Create(const aProcCardinal: TAProcCardinal);
begin
  FAProcCardinal       := aProcCardinal;
  methodAssigned       := assigned(aProcCardinal);
end;

constructor TAction.Create(const aProcStringString: TAProcStringString);
begin
  FAProcStringString   := aProcStringString;
  methodAssigned       := assigned(aProcStringString);
end;

constructor TAction.Create(const aProcStringBoolean: TAProcStringBoolean);
begin
  FAProcStringBoolean  := aProcStringBoolean;
  methodAssigned       := assigned(aProcStringBoolean);
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcNoParam): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcString): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcInteger): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcStringInteger): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcBoolean): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcWord): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcCardinal): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcStringString): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcStringBoolean): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(NIL);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcNoParam; const aFalseProc: TAProcNoParam): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcString; const aFalseProc: TAProcString): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcInteger; const aFalseProc: TAProcInteger): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcStringInteger; const aFalseProc: TAProcStringInteger): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcBoolean; const aFalseProc: TAProcBoolean): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcWord; const aFalseProc: TAProcWord): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcCardinal; const aFalseProc: TAProcCardinal): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcStringString; const aFalseProc: TAProcStringString): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;

class function TAction.pick(const aBoolean: boolean; const aTrueProc: TAProcStringBoolean; const aFalseProc: TAProcStringBoolean): TAction;
begin
  case aBoolean of
     TRUE:  result := TAction.Create(aTrueProc);
    FALSE:  result := TAction.Create(aFalseProc);
  end;
end;


function TAction.getMethodAssigned: boolean;
begin
  result := FMethodAssigned;
end;

procedure TAction.setMethodAssigned(const aValue: boolean);
begin
  FMethodAssigned := aValue;
end;

procedure TAction.perform();
begin
  try
    case assigned(FAProcNoParam) of TRUE: FAProcNoParam(); end;
  finally
    SELF.free;
  end;
end;

procedure TAction.perform(const aString: string);
begin
  try
    case assigned(FAProcString) of TRUE: FAProcString(aString); end;
  finally
    SELF.free;
  end;
end;

procedure TAction.perform(const aInteger: integer);
begin
  try
    case assigned(FAProcInteger) of TRUE: FAProcInteger(aInteger); end;
  finally
    SELF.free;
  end;
end;

procedure TAction.perform(const aString: string; const aInteger: integer);
begin
  try
    case assigned(FAProcStringInteger) of TRUE: FAProcStringInteger(aString, aInteger); end;
  finally
    SELF.free;
  end;
end;

procedure TAction.perform(const aBoolean: boolean);
begin
  try
    case assigned(FAProcBoolean) of TRUE: FAProcBoolean(aBoolean); end;
  finally
    SELF.free;
  end;
end;

procedure TAction.perform(const aWORD: WORD);
begin
  try
    case assigned(FAProcWord) of TRUE: FAProcWord(aWORD); end;
  finally
    SELF.free;
  end;
end;

procedure TAction.perform(const aCardinal: cardinal);
begin
  try
    case assigned(FAProcCardinal) of TRUE: FAProcCardinal(aCardinal); end;
  finally
    SELF.free;
  end;
end;

procedure TAction.perform(const aString1: string; const aString2: string);
begin
  try
    case assigned(FAProcStringString) of TRUE: FAProcStringString(aString1, aString2); end;
  finally
    SELF.free;
  end;
end;

procedure TAction.perform(const aString: string; const aBoolean: boolean);
begin
  try
    case assigned(FAProcStringBoolean) of TRUE: FAProcStringBoolean(aString, aBoolean); end;
  finally
    SELF.free;
  end;
end;

end.
