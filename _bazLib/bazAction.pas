unit bazAction;
{   bazLib / bazAction
    Copyright (C) 2021-2099 Baz Cuda
    https://github.com/BazzaCuda/

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
}

interface

{ THIS UNIT IS GENERATED BY bazActionGen.exe. AMEND THE bazActionDefs.txt FILE TO REGENERATE THIS UNIT FOR DIFFERENT FUNCTION TYPES AND FUNCTION SIGNATURES }
{ Add project-specific datatypes to IAction and TAction descendants in a separate unit }

type
  TVoid = record end;

  TOFuncNoParam             <TResult> = function():                                                                     TResult of object; // method of class instance
  TSFuncNoParam             <TResult> = function():                                                                     TResult;           // static method - no class instance
  TAFuncNoParam             <TResult> = reference to function():                                                        TResult;           // anonymous method

  TOFuncString              <TResult> = function(const aString: string):                                                TResult of object; // method of class instance
  TSFuncString              <TResult> = function(const aString: string):                                                TResult;           // static method - no class instance
  TAFuncString              <TResult> = reference to function(const aString: string):                                   TResult;           // anonymous method

  TOFuncInteger             <TResult> = function(const aInteger: integer):                                              TResult of object; // method of class instance
  TSFuncInteger             <TResult> = function(const aInteger: integer):                                              TResult;           // static method - no class instance
  TAFuncInteger             <TResult> = reference to function(const aInteger: integer):                                 TResult;           // anonymous method

  TOFuncStringInteger       <TResult> = function(const aString: string; const aInteger: integer):                       TResult of object; // method of class instance
  TSFuncStringInteger       <TResult> = function(const aString: string; const aInteger: integer):                       TResult;           // static method - no class instance
  TAFuncStringInteger       <TResult> = reference to function(const aString: string; const aInteger: integer):          TResult;           // anonymous method

  TOFuncBoolean             <TResult> = function(const aBoolean: boolean):                                              TResult of object; // method of class instance
  TSFuncBoolean             <TResult> = function(const aBoolean: boolean):                                              TResult;           // static method - no class instance
  TAFuncBoolean             <TResult> = reference to function(const aBoolean: boolean):                                 TResult;           // anonymous method

  IAction<TResult> = interface
    function perform():                                                                    TResult; overload;
    function perform(const aString: string):                                               TResult; overload;
    function perform(const aInteger: integer):                                             TResult; overload;
    function perform(const aString: string; const aInteger: integer):                      TResult; overload;
    function perform(const aBoolean: boolean):                                             TResult; overload;

    function getAssigned: boolean;
    property assigned:    boolean read getAssigned;
  end;

  TAction<TResult> = class(TInterfacedObject, IAction<TResult>)
  strict private
    FFuncAssigned: boolean;

    FOFuncNoParam:                      TOFuncNoParam                        <TResult>;
    FSFuncNoParam:                      TAFuncNoParam                        <TResult>;
    FAFuncNoParam:                      TAFuncNoParam                        <TResult>;

    FOFuncString:                       TOFuncString                         <TResult>;
    FSFuncString:                       TAFuncString                         <TResult>;
    FAFuncString:                       TAFuncString                         <TResult>;

    FOFuncInteger:                      TOFuncInteger                        <TResult>;
    FSFuncInteger:                      TAFuncInteger                        <TResult>;
    FAFuncInteger:                      TAFuncInteger                        <TResult>;

    FOFuncStringInteger:                TOFuncStringInteger                  <TResult>;
    FSFuncStringInteger:                TAFuncStringInteger                  <TResult>;
    FAFuncStringInteger:                TAFuncStringInteger                  <TResult>;

    FOFuncBoolean:                      TOFuncBoolean                        <TResult>;
    FSFuncBoolean:                      TAFuncBoolean                        <TResult>;
    FAFuncBoolean:                      TAFuncBoolean                        <TResult>;

    constructor Create;                           overload;
    constructor Create(const aFuncNIL: pointer);  overload;

    constructor Create(const aFuncNoParam:           TOFuncNoParam            <TResult>);     overload;
    constructor Create(const aFuncNoParam:           TSFuncNoParam            <TResult>);     overload;
    constructor Create(const aFuncNoParam:           TAFuncNoParam            <TResult>);     overload;

    constructor Create(const aFuncString:            TOFuncString             <TResult>);     overload;
    constructor Create(const aFuncString:            TSFuncString             <TResult>);     overload;
    constructor Create(const aFuncString:            TAFuncString             <TResult>);     overload;

    constructor Create(const aFuncInteger:           TOFuncInteger            <TResult>);     overload;
    constructor Create(const aFuncInteger:           TSFuncInteger            <TResult>);     overload;
    constructor Create(const aFuncInteger:           TAFuncInteger            <TResult>);     overload;

    constructor Create(const aFuncStringInteger:     TOFuncStringInteger      <TResult>);     overload;
    constructor Create(const aFuncStringInteger:     TSFuncStringInteger      <TResult>);     overload;
    constructor Create(const aFuncStringInteger:     TAFuncStringInteger      <TResult>);     overload;

    constructor Create(const aFuncBoolean:           TOFuncBoolean            <TResult>);     overload;
    constructor Create(const aFuncBoolean:           TSFuncBoolean            <TResult>);     overload;
    constructor Create(const aFuncBoolean:           TAFuncBoolean            <TResult>);     overload;

  public
    function getAssigned: boolean;

    class function pick(const aBoolean: boolean; const aTrueFuncNoParam:            TOFuncNoParam            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncNoParam:            TSFuncNoParam            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncNoParam:            TAFuncNoParam            <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncString:             TOFuncString             <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncString:             TSFuncString             <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncString:             TAFuncString             <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncInteger:            TOFuncInteger            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncInteger:            TSFuncInteger            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncInteger:            TAFuncInteger            <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncStringInteger:      TOFuncStringInteger      <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncStringInteger:      TSFuncStringInteger      <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncStringInteger:      TAFuncStringInteger      <TResult>):           IAction<TResult>; overload;

    class function pick(const aBoolean: boolean; const aTrueFuncBoolean:            TOFuncBoolean            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncBoolean:            TSFuncBoolean            <TResult>):           IAction<TResult>; overload;
    class function pick(const aBoolean: boolean; const aTrueFuncBoolean:            TAFuncBoolean            <TResult>):           IAction<TResult>; overload;

    function perform():                                                          TResult; overload;
    function perform(const aString: string):                                     TResult; overload;
    function perform(const aInteger: integer):                                   TResult; overload;
    function perform(const aString: string; const aInteger: integer):            TResult; overload;
    function perform(const aBoolean: boolean):                                   TResult; overload;
  end;

implementation

uses
  bazRTL;

{ TAction<TResult> }

constructor TAction<TResult>.Create;
begin
  raise exception.create('Don''t call TAction.create');
end;

constructor TAction<TResult>.Create(const aFuncNIL: pointer);
begin
  case aFuncNIL = NIL of   TRUE: EXIT;
                          FALSE: raise exception.Create('Functionless constructor must be called with NIL'); end;
end;

constructor TAction<TResult>.Create(const aFuncNoParam: TOFuncNoParam<TResult>);
begin
  FOFuncNoParam        := aFuncNoParam;
  FFuncAssigned        := assigned(aFuncNoParam);
end;

constructor TAction<TResult>.Create(const aFuncNoParam: TSFuncNoParam<TResult>);
begin
  FSFuncNoParam        := aFuncNoParam;
  FFuncAssigned        := assigned(aFuncNoParam);
end;

constructor TAction<TResult>.Create(const aFuncNoParam: TAFuncNoParam<TResult>);
begin
  FAFuncNoParam        := aFuncNoParam;
  FFuncAssigned        := assigned(aFuncNoParam);
end;

constructor TAction<TResult>.Create(const aFuncString: TOFuncString<TResult>);
begin
  FOFuncString         := aFuncString;
  FFuncAssigned        := assigned(aFuncString);
end;

constructor TAction<TResult>.Create(const aFuncString: TSFuncString<TResult>);
begin
  FSFuncString         := aFuncString;
  FFuncAssigned        := assigned(aFuncString);
end;

constructor TAction<TResult>.Create(const aFuncString: TAFuncString<TResult>);
begin
  FAFuncString         := aFuncString;
  FFuncAssigned        := assigned(aFuncString);
end;

constructor TAction<TResult>.Create(const aFuncInteger: TOFuncInteger<TResult>);
begin
  FOFuncInteger        := aFuncInteger;
  FFuncAssigned        := assigned(aFuncInteger);
end;

constructor TAction<TResult>.Create(const aFuncInteger: TSFuncInteger<TResult>);
begin
  FSFuncInteger        := aFuncInteger;
  FFuncAssigned        := assigned(aFuncInteger);
end;

constructor TAction<TResult>.Create(const aFuncInteger: TAFuncInteger<TResult>);
begin
  FAFuncInteger        := aFuncInteger;
  FFuncAssigned        := assigned(aFuncInteger);
end;

constructor TAction<TResult>.Create(const aFuncStringInteger: TOFuncStringInteger<TResult>);
begin
  FOFuncStringInteger  := aFuncStringInteger;
  FFuncAssigned        := assigned(aFuncStringInteger);
end;

constructor TAction<TResult>.Create(const aFuncStringInteger: TSFuncStringInteger<TResult>);
begin
  FSFuncStringInteger  := aFuncStringInteger;
  FFuncAssigned        := assigned(aFuncStringInteger);
end;

constructor TAction<TResult>.Create(const aFuncStringInteger: TAFuncStringInteger<TResult>);
begin
  FAFuncStringInteger  := aFuncStringInteger;
  FFuncAssigned        := assigned(aFuncStringInteger);
end;

constructor TAction<TResult>.Create(const aFuncBoolean: TOFuncBoolean<TResult>);
begin
  FOFuncBoolean        := aFuncBoolean;
  FFuncAssigned        := assigned(aFuncBoolean);
end;

constructor TAction<TResult>.Create(const aFuncBoolean: TSFuncBoolean<TResult>);
begin
  FSFuncBoolean        := aFuncBoolean;
  FFuncAssigned        := assigned(aFuncBoolean);
end;

constructor TAction<TResult>.Create(const aFuncBoolean: TAFuncBoolean<TResult>);
begin
  FAFuncBoolean        := aFuncBoolean;
  FFuncAssigned        := assigned(aFuncBoolean);
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncNoParam: TOFuncNoParam<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncNoParam);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncNoParam: TSFuncNoParam<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncNoParam);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncNoParam: TAFuncNoParam<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncNoParam);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncString: TOFuncString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncString);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncString: TSFuncString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncString);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncString: TAFuncString<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncString);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncInteger: TOFuncInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncInteger: TSFuncInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncInteger: TAFuncInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringInteger: TOFuncStringInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringInteger: TSFuncStringInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncStringInteger: TAFuncStringInteger<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncStringInteger);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncBoolean: TOFuncBoolean<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncBoolean);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncBoolean: TSFuncBoolean<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncBoolean);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

class function TAction<TResult>.pick(const aBoolean: boolean; const aTrueFuncBoolean: TAFuncBoolean<TResult>): IAction<TResult>;
begin
  case aBoolean of
     TRUE:  result := TAction<TResult>.Create(aTrueFuncBoolean);
    FALSE:  result := TAction<TResult>.Create(NIL);
  end;
end;

function TAction<TResult>.getAssigned: boolean;
begin
  result := FFuncAssigned;
end;

function TAction<TResult>.perform(): TResult;
begin
  result := default(TResult);
  case assigned(FOFuncNoParam) of TRUE: EXIT(FOFuncNoParam()); end;
  case assigned(FSFuncNoParam) of TRUE: EXIT(FSFuncNoParam()); end;
  case assigned(FAFuncNoParam) of TRUE: EXIT(FAFuncNoParam()); end;
end;

function TAction<TResult>.perform(const aString: string): TResult;
begin
  result := default(TResult);
  case assigned(FOFuncString) of TRUE: EXIT(FOFuncString(aString)); end;
  case assigned(FSFuncString) of TRUE: EXIT(FSFuncString(aString)); end;
  case assigned(FAFuncString) of TRUE: EXIT(FAFuncString(aString)); end;
end;

function TAction<TResult>.perform(const aInteger: integer): TResult;
begin
  result := default(TResult);
  case assigned(FOFuncInteger) of TRUE: EXIT(FOFuncInteger(aInteger)); end;
  case assigned(FSFuncInteger) of TRUE: EXIT(FSFuncInteger(aInteger)); end;
  case assigned(FAFuncInteger) of TRUE: EXIT(FAFuncInteger(aInteger)); end;
end;

function TAction<TResult>.perform(const aString: string; const aInteger: integer): TResult;
begin
  result := default(TResult);
  case assigned(FOFuncStringInteger) of TRUE: EXIT(FOFuncStringInteger(aString, aInteger)); end;
  case assigned(FSFuncStringInteger) of TRUE: EXIT(FSFuncStringInteger(aString, aInteger)); end;
  case assigned(FAFuncStringInteger) of TRUE: EXIT(FAFuncStringInteger(aString, aInteger)); end;
end;

function TAction<TResult>.perform(const aBoolean: boolean): TResult;
begin
  result := default(TResult);
  case assigned(FOFuncBoolean) of TRUE: EXIT(FOFuncBoolean(aBoolean)); end;
  case assigned(FSFuncBoolean) of TRUE: EXIT(FSFuncBoolean(aBoolean)); end;
  case assigned(FAFuncBoolean) of TRUE: EXIT(FAFuncBoolean(aBoolean)); end;
end;

end.
